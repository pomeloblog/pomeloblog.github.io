<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOP编程和反射实例</title>
    <url>/2024/07/28/AOP%E7%BC%96%E7%A8%8B%E5%92%8C%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="AOP编程和反射实例"><a href="#AOP编程和反射实例" class="headerlink" title="AOP编程和反射实例"></a>AOP编程和反射实例</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>利用AOP编程实现对数据库数据添加或更新时部分字段的自动赋值功能</p>
<ul>
<li>自定义注解AutoFill，用于标识需要部分字段自动填充的方法</li>
<li>自定义切面类AutoFillAspect，统一拦截加入了AutoFill注解的方法，通过反射为部分字段赋值</li>
</ul>
<h2 id="已有类"><a href="#已有类" class="headerlink" title="已有类"></a>已有类</h2><h3 id="Result—pojo"><a href="#Result—pojo" class="headerlink" title="Result—pojo"></a>Result—pojo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    Integer code;</span><br><span class="line">    String message;</span><br><span class="line">    Object object;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="User—pojo"><a href="#User—pojo" class="headerlink" title="User—pojo"></a>User—pojo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String password;</span><br><span class="line">    String role;</span><br><span class="line">    LocalDateTime createTime;</span><br><span class="line">    LocalDateTime updateTime;</span><br><span class="line">    String updateRole;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UserController—controller"><a href="#UserController—controller" class="headerlink" title="UserController—controller"></a>UserController—controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/insert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">insert</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userService.insert(user);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userService.update(user);</span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UserServiceImpl—service"><a href="#UserServiceImpl—service" class="headerlink" title="UserServiceImpl—service"></a>UserServiceImpl—service</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userMapper.update(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UserMapper—mapper"><a href="#UserMapper—mapper" class="headerlink" title="UserMapper—mapper"></a>UserMapper—mapper</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AutoFill(value = OperationType.INSERT)</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user (name, password, role,create_time, update_time, update_role)\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;values(#&#123;name&#125;,#&#123;password&#125;,#&#123;role&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;,#&#123;updateRole&#125;);&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AutoFill(value = OperationType.UPDATE)</span></span><br><span class="line">    <span class="meta">@Update(&quot;UPDATE user\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;SET update_time = #&#123;updateTime&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    update_role = #&#123;updateRole&#125;\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;WHERE id = #&#123;id&#125;;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h3><p>枚举类中存放了要用到的方法标识</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperationType</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSERT,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UPDATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义注释"><a href="#自定义注释" class="headerlink" title="自定义注释"></a>自定义注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span><span class="comment">// 设置该注解应用到方法上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoFill &#123;</span><br><span class="line">    OperationType <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义切面"><a href="#定义切面" class="headerlink" title="定义切面"></a>定义切面</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFillAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义切入点</span></span><br><span class="line"><span class="comment">     * execution(* com.example.demo.mapper.*.*(..))</span></span><br><span class="line"><span class="comment">     * 设置要扫描的包是mapper下的所有</span></span><br><span class="line"><span class="comment">     * annotation(com.example.demo.annotation.AutoFill)</span></span><br><span class="line"><span class="comment">     * 设置只有当使用AutoFill注解的时候才启用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.demo.mapper.*.*(..)) &amp;&amp; @annotation(com.example.demo.annotation.AutoFill)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFillPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;autoFillPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autoFill</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取被拦截方法的注解类型</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();<span class="comment">// 获取方法签名</span></span><br><span class="line">        <span class="type">AutoFill</span> <span class="variable">autoFill</span> <span class="operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);<span class="comment">// 获取方法上的注解对象</span></span><br><span class="line">        <span class="type">OperationType</span> <span class="variable">operationType</span> <span class="operator">=</span> autoFill.value();<span class="comment">// 获取注解的值</span></span><br><span class="line">        <span class="comment">// 2.获取被拦截方法的参数(约定添加注释的方法要赋值的参数为第一个参数)</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();<span class="comment">// 获取方法参数集合</span></span><br><span class="line">        <span class="keyword">if</span> (args == <span class="literal">null</span> || args.length == <span class="number">0</span>) &#123;<span class="comment">// 防止空指针报错</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">entity</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 3.准备要赋值的数据</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">String</span> <span class="variable">role</span> <span class="operator">=</span> <span class="string">&quot;用户&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">updateRole</span> <span class="operator">=</span> <span class="string">&quot;管理员&quot;</span>;</span><br><span class="line">        <span class="comment">// 4.根据注解值的类型利用反射进行相应的赋值操作</span></span><br><span class="line">        <span class="keyword">if</span> (operationType == OperationType.INSERT)&#123;</span><br><span class="line">            <span class="comment">// 为四个字段进行赋值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取字段的setter</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setRole</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setRole&quot;</span>, String.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setCreateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setCreateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateRole</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateRole&quot;</span>, String.class);</span><br><span class="line">                <span class="comment">// 通过反射进行赋值</span></span><br><span class="line">                setRole.invoke(entity,role);</span><br><span class="line">                setCreateTime.invoke(entity,now);</span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setUpdateRole.invoke(entity,updateRole);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (operationType == OperationType.UPDATE)&#123;</span><br><span class="line">            <span class="comment">// 为两个字段赋值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取字段的setter</span></span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateTime</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateTime&quot;</span>, LocalDateTime.class);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">setUpdateRole</span> <span class="operator">=</span> entity.getClass().getDeclaredMethod(<span class="string">&quot;setUpdateRole&quot;</span>, String.class);</span><br><span class="line">                <span class="comment">// 通过反射进行赋值</span></span><br><span class="line">                setUpdateTime.invoke(entity,now);</span><br><span class="line">                setUpdateRole.invoke(entity,updateRole);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>未被拦截时:<br><img src="/2024/07/28/AOP%E7%BC%96%E7%A8%8B%E5%92%8C%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B/user01.png"><br>拦截后:<br><img src="/2024/07/28/AOP%E7%BC%96%E7%A8%8B%E5%92%8C%E5%8F%8D%E5%B0%84%E5%AE%9E%E4%BE%8B/user02.png"></p>
]]></content>
  </entry>
  <entry>
    <title>如何快速搭建个人博客</title>
    <url>/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天，自己的博客也是正式上线了，虽然还有些简陋，不过我也会在后续慢慢美化。早在我在大二第一学期的时候就萌生了搭建自己博客的想法，由于一些原因，也是迟迟没有行动。前几天不知从哪里看到一则招聘信息，其中有一点要求有自己的技术博客，提醒了我一下。正好这几天事情比较少，可以静下来好好研究一下。</p>
<p>搭建一个自己的博客，每天分享一下自己学到的编程技巧，记录一下自己的学习轨迹，还能练习markdown书写的语法，等找工作到投简历的时候可以在简历上多加一条:精通markdown文档的书写（bushi</p>
<p>言归正传，下面就来分享一下自己建站都要做些什么，本教程采取 hexo 框架 butterfly 主题 github pages进行部署。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="编程工具"><a href="#编程工具" class="headerlink" title="编程工具"></a>编程工具</h2><h3 id="Vscode-Visual-Studio-Code"><a href="#Vscode-Visual-Studio-Code" class="headerlink" title="Vscode(Visual Studio Code)"></a>Vscode(Visual Studio Code)</h3><p>首先你要有一个代码编辑器，用于后续框架的配置修改。可以用webstorm或者vscode，这里我使用的是vscode。</p>
<p>安装十分简单，从<a href="https://code.visualstudio.com/">vscode官网</a>上就可以下载到安装包，之后正常安装就可以了。<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/vscode.png"><br>vscode插件商店有着丰富的插件供你选择，这里我推荐一个markdown预览插件Markdown Preview Enhanced，这个插件可以让你在编写markdown文档的时候实现实时预览。</p>
<h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><h3 id="GIthub"><a href="#GIthub" class="headerlink" title="GIthub"></a>GIthub</h3><p>github 是一个代码托管平台。最简单的理解就是把 github 当作一个云盘，只不过云盘里要上传的东西是你自己的代码，虽然这样表述有些不妥，但对于初学者来说再合适不过了。<br>首先我们要注册一个github账号，具体方式可以查看<a href="https://blog.csdn.net/sevenpens/article/details/129118026">这里</a>。<br>然后创建一个仓库，推荐可见性设置为 private，具体方式可以参考<a href="https://blog.csdn.net/u012693479/article/details/114892130">这里</a>。这个仓库就用来存放博客的代码，以后你本地的博客代码都可以通过 git 上传到这个仓库当作备份。</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><blockquote>
<p>git 是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL许可协议发布。</p>
</blockquote>
<p>这是维基百科上给出的介绍，通俗来讲，git 是一个版本控制软件，可以记录你代码的每一次修改，并且可以回滚到之前的版本。我并不打算深入讲解怎么使用git，这里只介绍如何安装 git，以及在搭建博客的过程中会用到的一些git命令，如果对 git 感兴趣可以查看 git 的<a href="https://git-scm.com/book/zh/v2">官方文档</a>。</p>
<p>进入git的<a href="https://git-scm.com/">官网</a>，点击Download for Windows后会跳转到有多种下载方式的二级页面，选择其中一种下载方式即可。<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/git01.png"><br>下载完成后，打开安装包，一路next即可。git安装默认是在C盘，若你想安装到其他盘上，修改安装路径即可，记得不要用中文路径。<br>安装完成后，在桌面右键鼠标可以发现多了两个选项，这两个选项就是git 的操作页面。一般情况下我都是使用 git 的命令行来操作 git 的，也就是第二个的 git bash。当然如果你喜欢 git 的图形化界面，你也可以使用第一个选项。<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/git02.png"><br>点击Open Git Bash here便是git的命令行界面，使用git -v命令可以查看当前你安装的git版本。<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/git03.png"><br>接下来要对git进行配置，这一步是必须要做的，目的是让 git 知道你的用户名和邮箱，这样在使用 git 提交代码的时候就会自动添加用户名和邮箱。<br>在刚刚打开的git bash中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">$ git config --global user.email 你的邮箱</span><br><span class="line">示例:</span><br><span class="line">$ git config --global user.name <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p>
</blockquote>
<p>如果你想通过windows自带的 cmd 或者 powershell 来使用 git，你需要配置环境变量，将 git 的 bin 目录添加到环境变量中。具体方法可参考<a href="https://blog.csdn.net/weixin_45811256/article/details/130925392">这里</a>。</p>
<h3 id="Node-js-和-npm"><a href="#Node-js-和-npm" class="headerlink" title="Node.js 和 npm"></a>Node.js 和 npm</h3><p>之所以安装 node 是因为我们搭建博客所使用的框架需要用到 node 环境<br>进入node的<a href="https://nodejs.org/zh-cn">官网</a>，点击下载（LTS是长期支持的版本），然后也是一路next<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/node01.png"><br>安装完成后，在Windows环境下，打开 cmd，然后输入<code>node -v</code>，如果安装正常，你应该看到 node 版本号的输出。<br>npm 是什么玩意？其实 npm 是 Node.js 的包管理工具（package manager），也就是用于安装依赖的工具。<br>npm 在安装 Node.js 的时候顺带装好了，我们只需要在 cmd 中输入<code>npm -v</code>，如果安装正常，你应该看到 npm 版本号的输出。<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/node02.png"></p>
<h2 id="安装框架"><a href="#安装框架" class="headerlink" title="安装框架"></a>安装框架</h2><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>做完以上的步骤，我们就把框架所需要的工具和环境准备好了，现在需要的就是安装一个框架。框架可以把你写的 markdown 文件一键转换成静态页面，你所需要做的仅仅是 markdown 文档的编写以及 hexo 相关命令的调用，大大简化了搭建博客的过程。通过安装 hexo 的插件，甚至可以实现一键部署到github pages，十分方便。<br>我这里使用的是 <a href="https://hexo.io/zh-cn/index.html">hexo</a>，hexo 是一个快速、简洁且高效的博客框架。<br>首先在 cmd 中使用 npm 包管理器全局安装 hexo:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，使用 npm 安装 hexo 的时候，你可能会遇到如下报错（如果没有可以直接跳过此处）:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm http GET https://registry.npmjs.org/yo</span><br><span class="line">npm ERR! network read ECONNRESET</span><br><span class="line">npm ERR! network This is most likely <span class="keyword">not</span> a problem with npm itself</span><br><span class="line">npm ERR! network and is related to network connectivity.</span><br><span class="line">npm ERR! network <span class="keyword">In</span> most cases you are behind a proxy or have bad network settings.</span><br><span class="line">npm ERR! network</span><br><span class="line">npm ERR! network <span class="keyword">If</span> you are behind a proxy, please make sure that the</span><br><span class="line">npm ERR! network &#x27;proxy&#x27; config is <span class="built_in">set</span> properly.  See: &#x27;npm <span class="built_in">help</span> config&#x27;</span><br></pre></td></tr></table></figure>
<p>不要担心，这是由于网络原因造成的报错，你可以为 npm 配置国内镜像源来解决这一问题<br>同样的，在 cmd 中输入:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://mirrors.huaweicloud.com/repository/npm/</span><br></pre></td></tr></table></figure>
<p>然后再次在 cmd 中输入:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>
<p>你将会看到控制台上输出了你刚才设置的网址<br>这个镜像是国内华为的，当然，你也可以设置其他的，具体网址网上可以搜到<br>安装完成后，就可以进行博客项目的初始化了<br>新建一个文件夹用于存放你要写的博客，然后在该文件夹中打开 cmd，输入:<br><code>$ hexo init</code><br>这条命令会从 hexo 官方仓库中克隆一些基础项目文件到你新建的文件夹中，文件夹中会多这些文件<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo01.png"><br>接下来安装项目所需的相关依赖，在 cmd 中输入:<br><code> $ npm install</code><br>安装完成之后你会看到类似如下输出:<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo02.png"><br>这里简单介绍一下各个文件或者文件夹的作用:</p>
</blockquote>
<ul>
<li>scaffolds: 这是你博客的模板文件夹，你可以在这里编写模板文件</li>
<li>source: 这是你博客的源码文件夹<ul>
<li>_draft: 这是你博客的草稿文件夹，你可以在这里编写 markdown 草稿</li>
<li>_posts: 这是你博客的博客文件夹，你可以在这里编写 markdown 文档，这里存放的都是你要发布到博客网站上的文档</li>
</ul>
</li>
<li>public: 执行<code>hexo generate</code>后生成的编译结果文件夹，你可以在这里查看你的博客</li>
<li>themes: 这是你博客的主题文件夹，你可以把喜欢的主题放到这个文件夹中</li>
<li>_config.yml: 这是你博客的配置文件，你可以在这里配置你的博客名称、主题、标签、分类、作者、邮箱、GitHub 链接等</li>
<li>在这些文件或文件夹中除了配置要用到 _config.yml 文件外，用到最多的就是 _post 文件夹了。<br>刚刚使用<code>npm init</code>初始化后会有一个 hexo 官方提供的博客样例，我们可以通过在 cmd 中输入:<br><code>$ npm server</code><br>来开启本地服务器，你想会看到如下输出:<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo03.png"><br>访问控制台输出的网站即可查看样例博客<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo04.png"><br>在 cmd 控制台中使用<code>ctrl + c</code>来关闭服务器<br>到此，你已经完成了搭建工作的一半，接下来我们就来进行另一半搭建工作。</li>
</ul>
<h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>虽然 hexo 的官方给我们提供了默认的主题，但既然是个人博客那一定要突出个人独特的风格，正好，我们可以通过应用不同的 hexo 主题来达到这个目的。</p>
<h2 id="butterfly"><a href="#butterfly" class="headerlink" title="butterfly"></a>butterfly</h2><p>本教程中使用 butterfly 主题，以下配置仅针对butterfly 主题。若你想应用其他主题可以在 github 上搜索<code>hexo theme</code>,相关主题配置可以参考官方文档。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>先来看一下 butterfly 主题的样子<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/butterfly01.png"><br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/butterfly02.png"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装butterfly 主题有多种方法，我推荐使用git clone 的方式.<br>在你的博客文件夹中打开 cmd 输入:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<p>这个命令会自动把butterfly 主题所需的相关文件从 butterfly 官方仓库克隆到 themes 文件夹中</p>
<h3 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h3><p>修改 hexo 根目录下的 _config.yml 文件，将主题名称修改为 butterfly</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape</span> <span class="string">--&gt;</span> <span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>hexo 默认是没有 pug 以及 stylus 的渲染器，所以要先安装hexo-renderer-pug 和 hexo-renderer-stylus两个插件<br>在博客文件夹中打开 cmd 输入:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>
<p>安装完成后运行运行<code>hexo server</code>命令，访问网站即可看到效果<br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/butterfly03.png"><br><img src="/2024/07/22/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/butterfly04.png"><br>当然这只是最基本的butterfly 主题的呈现效果，butterfly 主题还有更多的配置，支持各种自定义，具体可以参考<a href="https://butterfly.js.org/posts/21cfbf15/">butterfly官方文档</a>。</p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>当以上所有工作都完成后，执行<code>hexo generate</code>命令， hexo 会帮我们生成静态文件，通常情况下我们要做的就是把静态文件部署到自己的服务器上。</p>
<h2 id="github-pages"><a href="#github-pages" class="headerlink" title="github pages"></a>github pages</h2><p>github pages 是 github 提供的静态文件托管服务，我们只需要把静态文件上传到 github 仓库中，然后就可以通过 github pages 访问。</p>
<h3 id="创建github-pages站点"><a href="#创建github-pages站点" class="headerlink" title="创建github pages站点"></a>创建github pages站点</h3><p>page 站点的创建方式和普通仓库的创建方式基本上一样，只不过仓库名称是固定的为:<code>你的github用户名.github.io</code></p>
<blockquote>
<p>注意:</p>
<ul>
<li>如果你的用户名称包含大写字母，在创建 page 站点仓库时必须改成小写字母。</li>
<li>page 仓库的可见性设置为 public，不然你或者其他人无法通过 github pages 访问你的博客。</li>
</ul>
</blockquote>
<h2 id="安装hexo-deployer-git-插件"><a href="#安装hexo-deployer-git-插件" class="headerlink" title="安装hexo-deployer-git 插件"></a>安装hexo-deployer-git 插件</h2><p>hexo-deployer-git 插件可以让 hexo 实现一键部署至github pages<br>在博客文件夹中打开 cmd 输入:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>安装完成后，在博客根目录下的 _config.yml 文件中添加如下配置:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span> <span class="comment"># 你的page站点地址</span></span><br><span class="line">  <span class="attr">branch:</span> [<span class="string">branch</span>] <span class="comment"># 将代码上传到的分支，一般为main</span></span><br><span class="line">  <span class="attr">message:</span> [<span class="string">message</span>] <span class="comment"># 部署时生成的commit信息</span></span><br></pre></td></tr></table></figure>
<p>一切完成后便可以执行<code>hexo deploy</code>命令来一键部署自己的博客到github pages，别人只需要访问你的站点地址即可访问你的博客。<br>这样我们就完成了博客搭建的所有工作，虽然当前的博客有些简陋，我们可以通过相关主题的官方文档来进行自定义美化。<br>如果觉得这个教程对大家有所帮助，欢迎点赞、收藏、关注我的博客。</p>
]]></content>
  </entry>
  <entry>
    <title>四方考场科目三考试流程及注意点</title>
    <url>/2024/08/26/%E5%9B%9B%E6%96%B9%E8%80%83%E5%9C%BA%E7%A7%91%E7%9B%AE%E4%B8%89%E8%80%83%E8%AF%95%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<h1 id="四方考场C1科目三考试流程及注意点"><a href="#四方考场C1科目三考试流程及注意点" class="headerlink" title="四方考场C1科目三考试流程及注意点"></a>四方考场C1科目三考试流程及注意点</h1><h2 id="考试流程"><a href="#考试流程" class="headerlink" title="考试流程"></a>考试流程</h2><h3 id="1-进车检查"><a href="#1-进车检查" class="headerlink" title="1. 进车检查"></a>1. 进车检查</h3><ol>
<li>调节座椅</li>
<li>调节左右后视镜</li>
<li>检查发动机是否熄火</li>
<li>检查挡位是否处于空挡</li>
<li>检查手刹是否拉上</li>
<li>检查灯光是否关闭且处于近光灯挡位</li>
</ol>
<blockquote>
<p>进车检查可以不系安全带的</p>
</blockquote>
<blockquote>
<p>检查完成后，安全员会问你“是否可以开始考试”，你应该回“可以开始考试”。这时候会有拍照的语音提示，你应该面向摄像头，等待拍照完后会有语音提示。验证信息通过后会有“可以开始考试”的语音播报，这个时候，你就可以下车进行逆时针旋转一周的动作了</p>
</blockquote>
<h3 id="2-绕车一周"><a href="#2-绕车一周" class="headerlink" title="2. 绕车一周"></a>2. 绕车一周</h3><p>听到“开始考试”的语音播报后</p>
<ol>
<li>观察左后视镜，确认没有来车后，打开车门</li>
<li>逆时针绕车转一周，途中需要摁下车身的按钮，每按一个都要确定车内是否有相应语音播报响起再摁下一个按钮</li>
<li>完成后观察四周，确认开门无危险后打开车门回到车内，并顺势系上安全带</li>
</ol>
<blockquote>
<p>不同考场车身的按钮位置不同，具体位置可以询问模拟教练</p>
<p>注意：四方考场车身按钮分布：车头两个，车尾两个，共四个</p>
</blockquote>
<blockquote>
<p>有的考场在你回到车内系上安全带后会有“请启动发动机以进行灯光模拟考试”的语音播报，而有的考场没有，如果你回到车中迟迟没有相关语音播报可以自己打火启动车辆</p>
<p>注意：四方考场没有该语音提示</p>
</blockquote>
<h3 id="3-灯光模拟"><a href="#3-灯光模拟" class="headerlink" title="3. 灯光模拟"></a>3. 灯光模拟</h3><p>首先根据语音播报（若有的话）启动发动机：踩住离合+旋转钥匙</p>
<blockquote>
<p>启动发动机后会有“现在开始灯光模拟考试，请根据语音提示做出合适的灯光变化”之类的语音</p>
</blockquote>
<h4 id="近光灯"><a href="#近光灯" class="headerlink" title="近光灯"></a>近光灯</h4><ol>
<li>夜间会车</li>
<li>夜间同方向近距离跟车</li>
<li>夜间在有路灯&#x2F;照明良好的道路行驶</li>
<li>夜间通过路口（易错）</li>
</ol>
<h4 id="远光灯"><a href="#远光灯" class="headerlink" title="远光灯"></a>远光灯</h4><ol>
<li>夜间照明不良的道路行驶</li>
</ol>
<h4 id="远近交替"><a href="#远近交替" class="headerlink" title="远近交替"></a>远近交替</h4><ol>
<li>通过拱桥&#x2F;坡路&#x2F;急弯&#x2F;人行横道</li>
<li>夜间通过没有交通信号灯的路口（易错）</li>
</ol>
<h4 id="示廓灯-危险报警闪光灯"><a href="#示廓灯-危险报警闪光灯" class="headerlink" title="示廓灯+危险报警闪光灯"></a>示廓灯+危险报警闪光灯</h4><ol>
<li>路边临时停车</li>
<li>路上发生障碍&#x2F;交通事故难以移动</li>
</ol>
<blockquote>
<p>灯光模拟完成后会有“灯光模拟考试完成，请起步完成考试”的语音播报</p>
</blockquote>
<h3 id="4-起步"><a href="#4-起步" class="headerlink" title="4. 起步"></a>4. 起步</h3><p>听到相关语音播报后起步</p>
<ol>
<li>踩离合</li>
<li>挂一档</li>
<li>打开左转向灯</li>
<li>左右观望</li>
<li>摁一声喇叭</li>
<li>松离合松手刹</li>
</ol>
<blockquote>
<p>第六步：有的教练要求半联动起步，就是先放大概一半离合，然后松开手刹放另外一半离合；有的教练要求先放手刹，然后再放离合。</p>
<p>以自己教练为准</p>
</blockquote>
<p>松开离合后向左打45°方向，可以1档进入左车道后再升为2档也可以在进入左车道的过程中提速至10-15然后换为2档，看情况而定</p>
<p>进入左车道后及时关闭转向灯，此时起步动作完成</p>
<blockquote>
<p>特殊情况：如果你起步的那条道就是待会你要转弯的车道且起步点和转弯点离的也比较近，起步时你可以不用变到左车道，而是只打左转向灯不变道，后续动作和正常起步一样</p>
</blockquote>
<blockquote>
<p>注意：</p>
<ol>
<li>左转向灯亮3秒后才可以向左车道变道</li>
<li>向左打方向时幅度不能太大，容易掉灯（灯掉了即使补上即可），一般都是45°左右合适</li>
<li>离合丢的不能太快，要慢慢抬起，但也不能太慢，有时间限制，具体问自己教练，一般正常起步都不会超时</li>
<li>起步时1档和2档有距离限制，能换高档尽量换成高档</li>
</ol>
</blockquote>
<h3 id="5-中途项目"><a href="#5-中途项目" class="headerlink" title="5. 中途项目"></a>5. 中途项目</h3><h4 id="加减档（无语音播报，需自己在合适路段完成）"><a href="#加减档（无语音播报，需自己在合适路段完成）" class="headerlink" title="加减档（无语音播报，需自己在合适路段完成）"></a>加减档（无语音播报，需自己在合适路段完成）</h4><p>该项目没有语音播报，安全员也不会提醒，需要你在合适的路段自己完成</p>
<p>在合适的路段，（3档）踩油门，速到达到30-35之间后踩离合换为4档，加速至40-45保持三秒左右，然后踩刹车减速到30，踩离合换为3档，到此加减档项目完成</p>
<h4 id="超车（有语音播报）"><a href="#超车（有语音播报）" class="headerlink" title="超车（有语音播报）"></a>超车（有语音播报）</h4><p>该项目会由安全员发出，听到“请超越前方车辆”的语音播报后，便可以开始该项目</p>
<ol>
<li>打开左转向灯，等待3秒后观察左侧后视镜是否安全，确认安全后方向盘向左大概45°，进入左车道后向右打方向回正车身，及时关闭左转向灯</li>
<li>在左车道行驶大概3-5秒</li>
<li>打开右转向灯，等待3秒后观察右侧后视镜是否安全，确认安全后方向盘向右大概45°，回到原来车道后向左打方向回正车身，及时关闭右转向灯</li>
</ol>
<p>至此该项目完成</p>
<blockquote>
<p>注意：完成超车项目后不能着急变道，需要等待大概8秒左右的时间再进行后续变道操作</p>
</blockquote>
<h4 id="调头（有语音播报）"><a href="#调头（有语音播报）" class="headerlink" title="调头（有语音播报）"></a>调头（有语音播报）</h4><p>该项目有语音播报，听到“前方路口请调头”的语音播报后，</p>
<ol>
<li>立即打开左转向灯，并轻点刹车减速至20，踩离合换为2档</li>
<li>三不踩，此时离合、刹车、油门均不踩，怠速滑行道至调头点（虚线处&#x2F;人行横道）</li>
<li>观察有无对向来车，若安全则立刻把方向打死，待车头过一半线后慢慢回正方向</li>
<li>关闭左转向灯</li>
<li>及时加速升至3档</li>
</ol>
<blockquote>
<p>注意：</p>
<ul>
<li>如果调头时有对向车辆且较多，可以踩离合踩刹车把车子停在原地（不能停在人行横道上），等情况好转后再启动车辆完成调头动作</li>
<li>二档没有速度下限，不用担心怠速时速度过低被挂</li>
<li>有的地方需要1档转弯，以自己教练为准</li>
</ul>
</blockquote>
<h4 id="与机动车会车（有语音播报）"><a href="#与机动车会车（有语音播报）" class="headerlink" title="与机动车会车（有语音播报）"></a>与机动车会车（有语音播报）</h4><p>该项目由安全员在合适路段发起，听到“前方与机动车会车”的语音播报后点一脚刹车即可，只要速度没有降至20以下都可以</p>
<p>点完刹车后迅速踩油门把速度保持在25-30之间</p>
<h4 id="斑马线（人行横道）-学校-公交车（无语音播报，需要在特定地点完成）"><a href="#斑马线（人行横道）-学校-公交车（无语音播报，需要在特定地点完成）" class="headerlink" title="斑马线（人行横道）&#x2F;学校&#x2F;公交车（无语音播报，需要在特定地点完成）"></a>斑马线（人行横道）&#x2F;学校&#x2F;公交车（无语音播报，需要在特定地点完成）</h4><p>这三个项目均无语音播报，需要自己在看到路标后自行踩一脚刹车减速</p>
<blockquote>
<p>注意：</p>
<ul>
<li>在车头距离斑马线&#x2F;公交站牌&#x2F;学校站牌1-2个车身左右就可以点刹车</li>
<li>刹车的速度不能低于20，刹车后迅速踩油门提速至25-30</li>
<li>这三个项目地点比较固定，可以在考试前自己去考场记下位置</li>
<li>快到这三个项目的地方时可以适当提速，等快到了再点刹车可以保证刹车后的速度不低于20</li>
</ul>
</blockquote>
<h4 id="红绿灯（无语音提示）"><a href="#红绿灯（无语音提示）" class="headerlink" title="红绿灯（无语音提示）"></a>红绿灯（无语音提示）</h4><h5 id="直行"><a href="#直行" class="headerlink" title="直行"></a>直行</h5><h6 id="直行时红灯"><a href="#直行时红灯" class="headerlink" title="直行时红灯"></a>直行时红灯</h6><p>踩离合+踩刹车，把车子停在合适位置</p>
<ul>
<li>如果你是该车道的第一辆车，起步时正常起步，1档换2档，2档换3档</li>
<li>如果你不是该车道的第一辆车，起步时迅速提速至10-15换为2档，稍微提速，快到路口时点一下刹车，然后再提速换成3档</li>
</ul>
<blockquote>
<ul>
<li>起步时慢丢离合，太快容易熄火</li>
<li>1档和2档均有距离限制，具体可以询问教练</li>
</ul>
</blockquote>
<h6 id="直行时绿灯"><a href="#直行时绿灯" class="headerlink" title="直行时绿灯"></a>直行时绿灯</h6><ul>
<li>如果绿灯时间足够，可以三档通过，但到路口时要点一下刹车</li>
<li>如果绿灯时间不足，要及时踩离合+踩刹车停车，等下个绿灯后再起步</li>
</ul>
<h5 id="路口转弯（有语音提示）（左转看红绿灯，右转不用）"><a href="#路口转弯（有语音提示）（左转看红绿灯，右转不用）" class="headerlink" title="路口转弯（有语音提示）（左转看红绿灯，右转不用）"></a>路口转弯（有语音提示）（左转看红绿灯，右转不用）</h5><p>听到“前方路口左&#x2F;右转”的语音播报时，立马打开相应转向灯</p>
<h6 id="左转时红灯"><a href="#左转时红灯" class="headerlink" title="左转时红灯"></a>左转时红灯</h6><p>踩离合+踩刹车，把车子停在合适位置，待下个绿灯时起步，看准自己要进入的车道，适当调整方向盘的角度</p>
<blockquote>
<p>注意：</p>
<ul>
<li>如果转弯半径较小时，可以用1档转弯</li>
<li>如果转弯半径较大，在起步后，迅速给一脚油门，提速至10-15，踩离合换为2档</li>
<li>转弯完成后迅速提速至20-25，踩离合升为3档</li>
<li>1档和2档有距离限制</li>
</ul>
</blockquote>
<h6 id="左转时绿灯"><a href="#左转时绿灯" class="headerlink" title="左转时绿灯"></a>左转时绿灯</h6><p>保持3档，稍微提速到25-30，等车头快到路口实线时，踩一脚刹车，减速到20，然后踩离合换为2档（丢离合时慢一点），最后以2档完成左转</p>
<h6 id="右转"><a href="#右转" class="headerlink" title="右转"></a>右转</h6><ul>
<li>如果红绿灯是圆形，则不论为红灯还是绿灯，均可以进行右转</li>
<li>如果红绿灯是箭头型，要等右转箭头指示灯为绿灯时才可以右转</li>
</ul>
<p>听到“前方路口右转”的语音播报后及时打开右转向灯，可以右转时，保持3档，稍微提速至25-30，等车头快到路口实线时踩一脚刹车，减速至20，然后踩离合换为2档，最后以2档完成右转，然后提速至25换为3档。</p>
<blockquote>
<p>1档和2档均有距离限制</p>
</blockquote>
<h4 id="直线行驶（有语音播报）"><a href="#直线行驶（有语音播报）" class="headerlink" title="直线行驶（有语音播报）"></a>直线行驶（有语音播报）</h4><p>该项目由安全员在合适路段发出，听到“请直线行驶”的语音播报后，保持当前运动即可</p>
<p>直线行驶过程中可以微调方向盘，大小不超过5°即可</p>
<h3 id="靠边停车（有语音播报）"><a href="#靠边停车（有语音播报）" class="headerlink" title="靠边停车（有语音播报）"></a>靠边停车（有语音播报）</h3><p>该项目由安全员在合适路段发出，当听到“请靠边停车”的语音播报后，</p>
<ol>
<li>立即打开右转灯并踩一脚刹车，减速至20，然后踩离合换为2档</li>
<li>待右转灯闪烁3秒后，观察右侧后视镜是否有车，确认安全后，向右微打方向（大概45°）</li>
<li>待车头过线一半后向左微打方向回正车身</li>
<li>眼睛注视左边雨刷块和白线是否对齐</li>
<li>对齐后，观察右侧后视镜中车身和白线的距离，左右微调方向盘，使距离大概1-2个手指即可</li>
<li>位置合适后踩离合+踩刹车，停车即可</li>
</ol>
<p>停车后按照顺序回位</p>
<ol>
<li>拉手刹</li>
<li>挂空挡</li>
<li>双脚离开（离合+刹车）</li>
<li>关闭左转向灯</li>
<li>关闭雨刷器（若下雨）</li>
<li>关闭发动机</li>
<li>解开安全带</li>
<li>打开车门（注意观察左后视镜是否有车，确认安全后下车并关闭车门）</li>
</ol>
<p>听到“成绩合格，请回中心考场打印成绩单”表明你已经正常通过科目三了</p>
<blockquote>
<p>有些考场在靠边停车时用1档去对齐边线</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>跨域及其解决方案</title>
    <url>/2024/08/03/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h2><h3 id="什么是源"><a href="#什么是源" class="headerlink" title="什么是源"></a>什么是源</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">源 = 协议 + 域名 +  端口号</span><br><span class="line">       |      |        |</span><br><span class="line">     http:<span class="comment">//localhost:8080</span></span><br></pre></td></tr></table></figure>

<p>源分为两类</p>
<ul>
<li>同源</li>
<li>非同源（跨域）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">源1</th>
<th align="center">源2</th>
<th align="center">是否同源</th>
<th align="center">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="http://www.xyz.com/home">http://www.xyz.com/home</a></td>
<td align="center"><a href="https://www.xyz.com/home">https://www.xyz.com/home</a></td>
<td align="center">×非同源️</td>
<td align="center">协议不同</td>
</tr>
<tr>
<td align="center"><a href="http://www.xyz.com/home">http://www.xyz.com/home</a></td>
<td align="center"><a href="http://mail.xyz.com/home">http://mail.xyz.com/home</a></td>
<td align="center">×非同源️</td>
<td align="center">域名不同</td>
</tr>
<tr>
<td align="center"><a href="http://www.xyz.com:8080/home">http://www.xyz.com:8080/home</a></td>
<td align="center"><a href="http://www.xyz.com:8090/home">http://www.xyz.com:8090/home</a></td>
<td align="center">×非同源️</td>
<td align="center">端口不同</td>
</tr>
<tr>
<td align="center"><a href="http://www.xyz.com:8080/home">http://www.xyz.com:8080/home</a></td>
<td align="center"><a href="http://www.xyz.com:8080/search">http://www.xyz.com:8080/search</a></td>
<td align="center">√同源</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>注意：源是不看路径的，只看协议、域名和端口号，比如表格最后一行两个路径中虽然一个为<code>/home</code>一个为<code>/search</code>，但这两个路径的协议、域名和端口号都相同，所以就认为这两个路径同源。</p>
</blockquote>
<blockquote>
<p>补充：同源之间相互请求称为同源请求，比如<code>http://aaa.com/user</code>去请求<code>http://aaa.com/user/login</code>就称为同源请求。</p>
</blockquote>
<h3 id="跨域受到的限制"><a href="#跨域受到的限制" class="headerlink" title="跨域受到的限制"></a>跨域受到的限制</h3><p>跨域是浏览器的一种同源策略的限制，所以当进行跨域请求时浏览器会针对跨域做出一些限制</p>
<blockquote>
<p>假设<strong>源A</strong>和<strong>源B</strong>非同源</p>
</blockquote>
<ol>
<li><p>DOM 访问限制</p>
<p> <strong>源A</strong>的脚本不能读取和操作<strong>源B</strong>的DOM</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;framePage&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./demo.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--&lt;iframe id=&quot;framePage&quot; src=&quot;https://www.baidu.com&quot;&gt;&lt;/iframe&gt;--&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 获取iframe标签中的页面DOM</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">showDOM</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> framePage = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;framePage&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 同源的可以获取，非同源的无法获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(framePage.<span class="property">contentWindow</span>.<span class="property">document</span>) </span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Cookie 访问限制</p>
<p><strong>源A</strong>的脚本不能读取和操作<strong>源B</strong>的Cookie</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;framePage&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./demo.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--&lt;iframe id=&quot;baidu&quot; src=&quot;http://www.baidu.com&quot;&gt;&lt;/iframe&gt;--&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">showCookie</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="variable language_">document</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;framePage&#x27;</span>).<span class="property">contentWindow</span>.<span class="property">document</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 同源的可以获取，非同源的无法获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Ajax 响应数据限制（最常见）</p>
<p><strong>源A</strong>可以给<strong>源B</strong>发送请求，但是<strong>源A</strong>无法获取<strong>源B</strong>响应回来的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> &gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">showCookie</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="string">&#x27;https://www.toutiao.com/hot-event/hot-board/?origin=toutiao_pc&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = <span class="keyword">await</span> result.<span class="title function_">json</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 同源的可以获取，非同源的无法获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>跨域的限制仅存在浏览器端，服务端不存在跨域限制</p>
</li>
<li><p>虽然同源策略限制了Ajax请求的响应数据，但是请求本身可以发出去，只是响应的数据接收不到</p>
<p><img src="/2024/08/03/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%B7%A8%E5%9F%9F01.png" alt="跨域01.png"></p>
</li>
<li><p><code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>…这些标签发出的请求也存在跨域问题，只不过浏览器对这些标签的跨域不做严格的要求，几乎无影响</p>
</li>
</ol>
<h2 id="CORS-概述"><a href="#CORS-概述" class="headerlink" title="CORS 概述"></a>CORS 概述</h2><h3 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS ?"></a>什么是 CORS ?</h3><p>CORS 全称：<code>Cross-Origin Resource Sharing</code>（跨域资源共享），是用于控制浏览器校验跨域请求的一套规范，服务器依照 CORS 规范，添加特定响应头来控制浏览器校验，大致规则如下：</p>
<ul>
<li>服务器明确表示拒绝跨域请求，或没有表示，则浏览器校验不通过</li>
<li>服务器明确表示允许跨域请求，则浏览器校验通过</li>
</ul>
<h3 id="简单请求和复杂请求"><a href="#简单请求和复杂请求" class="headerlink" title="简单请求和复杂请求"></a>简单请求和复杂请求</h3><p>CORS 会把请求分为两类，分别是： 简单请求和复杂请求，两种请求利用CORS解决跨域问题时有些许不同</p>
<p>那应该怎么去区分简单请求和复杂请求呢？</p>
<table>
<thead>
<tr>
<th align="left">简单请求</th>
</tr>
</thead>
<tbody><tr>
<td align="left">请求方法为：GET、POST、HEAD</td>
</tr>
<tr>
<td align="left">请求头字段符合<a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header">《CORS安全规范》</a> (只要不手动修改请求头，一般都能符合规范)</td>
</tr>
<tr>
<td align="left">请求头的Content-Type的值只能是以下三种：<br/>1. text&#x2F;plain<br/>2. multipart&#x2F;form-data<br/>3. application&#x2F;x-www-form-urlencoded</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">复杂请求</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1. 不是简单请求，就是复杂请求<br/>2. 复杂请求在发出真正请求前会先发送预检请求</td>
</tr>
</tbody></table>
<blockquote>
<p>关于预检请求</p>
<ul>
<li>发送时机：在实际跨域请求之前由浏览器自动发出</li>
<li>主要作用：向服务器确认是否允许接下来的跨域请求</li>
<li>基本流程：先发起OPTIONS预检请求，如果请求通过，则发出真正的跨域请求</li>
<li>请求头内容：一个OPTIONS预检请求，通常会包含如下请求头：<table>
<thead>
<tr>
<th>请求头</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Origin</td>
<td>发起请求的源</td>
</tr>
<tr>
<td>Access-Control-Request-Method</td>
<td>实际请求的 HTTP 方法</td>
</tr>
<tr>
<td>Access-Control-Request-Headers</td>
<td>实际请求中使用的自定义头（如果有的话）</td>
</tr>
</tbody></table>
<img src="/2024/08/03/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%B7%A8%E5%9F%9F02.png" alt="跨域02.png"></li>
</ul>
</blockquote>
<h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><h3 id="CORS-解决"><a href="#CORS-解决" class="headerlink" title="CORS 解决"></a>CORS 解决</h3><h4 id="CORS-解决简单请求跨域"><a href="#CORS-解决简单请求跨域" class="headerlink" title="CORS 解决简单请求跨域"></a>CORS 解决简单请求跨域</h4><p><strong>思路</strong>：服务器在给出响应时，通过添加Access-Control-Allow-Origin响应头，来明确表达允许某个源发起跨域请求，随后浏览器在校验时，直接通过。</p>
<p><img src="/2024/08/03/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%B7%A8%E5%9F%9F03.png" alt="跨域03.png"></p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#<span class="comment">// 服务端</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8080/&#x27;</span>)</span><br><span class="line">  <span class="comment">// res.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;) // 设置为所有请求均可访问，不推荐</span></span><br><span class="line">  res.<span class="title function_">send</span>()  <span class="comment">// 发送响应数据</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注意，当在开发阶段时，使用浏览器向本地服务器发送请求，</span></span><br><span class="line"><span class="comment">// 服务器在添加Access-Control-Allow-Origin响应头时</span></span><br><span class="line"><span class="comment">// 不要把127.0.0.1改成localhost</span></span><br></pre></td></tr></table></figure>

<h4 id="CORS-解决复杂请求跨域"><a href="#CORS-解决复杂请求跨域" class="headerlink" title="CORS 解决复杂请求跨域"></a>CORS 解决复杂请求跨域</h4><p><strong>步骤</strong>：</p>
<ol>
<li>服务器先通过浏览器的预检请求，服务器需要返回如下响应头：</li>
</ol>
<table>
<thead>
<tr>
<th>响应头</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Access-Control-Allow-Origin</td>
<td>允许的源</td>
</tr>
<tr>
<td>Access-Control-Allow-Methods</td>
<td>允许的方法</td>
</tr>
<tr>
<td>Access-Control-Allow-Headers</td>
<td>允许的自定义头</td>
</tr>
<tr>
<td>Access-Control-Max-Age</td>
<td>预检请求的结果缓存时间（可选）</td>
</tr>
</tbody></table>
<p><img src="/2024/08/03/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%B7%A8%E5%9F%9F04.png" alt="跨域04.png"></p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">options</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置允许的跨域请求源</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>)</span><br><span class="line">  <span class="comment">// 设置允许的请求方法</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line">  <span class="comment">// 设置允许的请求头</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;school&#x27;</span>)</span><br><span class="line">  <span class="comment">// 发送响应</span></span><br><span class="line">  res.<span class="title function_">send</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常还会在请求头中加上预检请求的缓存时间，当缓存时间未过期时再次发送相同复杂请求时无需预检</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置预检请求的缓存时间（可选）</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Max-Age&#x27;</span>, <span class="number">7200</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li>处理实际的跨域请求（与处理简单请求跨域的方式略有不同）</li>
</ol>
<p><img src="/2024/08/03/%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%B7%A8%E5%9F%9F03.png" alt="跨域03.png"></p>
<p>示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/students&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置允许的跨域请求源</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>)</span><br><span class="line">  <span class="comment">// 设置一个自定义响应头</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;abc&#x27;</span>,<span class="number">123</span>)</span><br><span class="line">  <span class="comment">// 设置允许暴露给客户端的响应头（必须有，默认js是不能访问后端自定义设置的响应头的，需要后端暴露）</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Expose-Headers&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">  <span class="comment">// 发送响应数据</span></span><br><span class="line">  res.<span class="title function_">send</span>(students)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>借助 cors 库快速完成配置（node.js）</p>
<p>安装cors库</p>
<p><code>npm install cors</code></p>
<p>最简单的配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入cors库</span></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最简单的配置，允许所有源跨域，允许所有方法跨域</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br></pre></td></tr></table></figure>

<p>比较完整的配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cors中间件配置</span></span><br><span class="line"><span class="keyword">const</span> corsOptions = &#123;</span><br><span class="line">  <span class="attr">origin</span>: <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>, <span class="comment">// 允许的源</span></span><br><span class="line">  <span class="attr">methods</span>: [<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>, <span class="string">&#x27;DELETE&#x27;</span>, <span class="string">&#x27;HEAD&#x27;</span>, <span class="string">&#x27;OPTIONS&#x27;</span>], <span class="comment">// 允许的方法</span></span><br><span class="line">  <span class="attr">allowedHeaders</span>: [<span class="string">&#x27;school&#x27;</span>], <span class="comment">// 允许的自定义头</span></span><br><span class="line">  <span class="attr">exposedHeaders</span>: [<span class="string">&#x27;abc&#x27;</span>], <span class="comment">// 要暴露的响应头</span></span><br><span class="line">  <span class="attr">optionsSuccessStatus</span>: <span class="number">200</span> <span class="comment">// 预检请求成功的状态码</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>(corsOptions)); <span class="comment">// 使用cors中间件</span></span><br></pre></td></tr></table></figure>
</blockquote>
<br/>

<h3 id="配置代理服务器解决跨域"><a href="#配置代理服务器解决跨域" class="headerlink" title="配置代理服务器解决跨域"></a>配置代理服务器解决跨域</h3><p><strong>思路</strong>：服务器之间是没有跨域问题的</p>
<h4 id="自己配置代理服务器（node-js）"><a href="#自己配置代理服务器（node-js）" class="headerlink" title="自己配置代理服务器（node.js）"></a>自己配置代理服务器（node.js）</h4><p>方式：借助<code>http-proxy-middleware</code>配置代理</p>
<p>安装<code>npm install http-proxy-middleware</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入http-proxy-middleware包</span></span><br><span class="line"><span class="keyword">const</span> &#123;createProxyMiddleware&#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动静态资源 确保页面跟服务器同一个源</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&quot;./public&quot;</span>));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>,<span class="title function_">createProxyMiddleware</span>(&#123;</span><br><span class="line">  <span class="comment">// 转发请求的目的地</span></span><br><span class="line">  <span class="attr">target</span>:<span class="string">&#x27;https://www.toutiao.com&#x27;</span>,</span><br><span class="line">  <span class="comment">// 是否允许跨域</span></span><br><span class="line">  <span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">pathRewrite</span>:&#123;</span><br><span class="line">    <span class="comment">// 转发出去的路径自动把/api字段去掉</span></span><br><span class="line">    <span class="string">&#x27;^/api&#x27;</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务器启动，监听8080端口！&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果可以修改后端代码，推荐使用CORS 去解决跨域问题，如果不能修改后端代码，推荐使用代理服务器解决跨域问题 </p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>微机原理与接口技术实验</title>
    <url>/2024/09/30/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="实验一：汇编程序基础实验"><a href="#实验一：汇编程序基础实验" class="headerlink" title="实验一：汇编程序基础实验"></a>实验一：汇编程序基础实验</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol>
<li>熟悉汇编程序开发、运行和调试</li>
<li>熟悉汇编程序的结构和分段概念</li>
<li>熟悉8086寻址方式和应用</li>
<li>熟悉数据传送、算数&#x2F;逻辑运算、流程控制等常见指令</li>
</ol>
<h2 id="实验内容（5选4）"><a href="#实验内容（5选4）" class="headerlink" title="实验内容（5选4）"></a>实验内容（5选4）</h2><ol>
<li>寄存器读写(和调试)实验</li>
<li>一维数值数组处理实验</li>
<li>字符串处理实验</li>
<li>二维数组处理实验</li>
<li>位处理实验</li>
</ol>
<h2 id="实验指南"><a href="#实验指南" class="headerlink" title="实验指南"></a>实验指南</h2><h3 id="实验1-1-寄存器读写-和调试-实验"><a href="#实验1-1-寄存器读写-和调试-实验" class="headerlink" title="实验1.1 寄存器读写(和调试)实验"></a>实验1.1 寄存器读写(和调试)实验</h3><h4 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h4><p>为4个通用数据寄存器AX、BX、CX、DX赋4个不同初值。用其他寄存器做中介交换AX与BX的值。用栈做中介交换CX与DX的值。交换AX的高8位和低8位。</p>
<h4 id="实验考查"><a href="#实验考查" class="headerlink" title="实验考查"></a>实验考查</h4><p>编程环境(和调试 )、寄存器、堆栈操作、程序结构</p>
<h4 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODE</span><br><span class="line">CODE SEGMENT</span><br><span class="line">start:</span><br><span class="line">        ; 初始化寄存器</span><br><span class="line">        MOV AX, 1234H</span><br><span class="line">        MOV BX, 5678H</span><br><span class="line"></span><br><span class="line">        ; 利用CX为中介交换AX和BX的值</span><br><span class="line">        MOV CX, AX</span><br><span class="line">        MOV AX, BX</span><br><span class="line">        MOV BX, CX</span><br><span class="line"></span><br><span class="line">        ; 初始化寄存器</span><br><span class="line">        MOV CX, 9ABCH</span><br><span class="line">        MOV DX, 4321H</span><br><span class="line"></span><br><span class="line">        ; 利用栈交换CX和DX的值</span><br><span class="line">        PUSH CX</span><br><span class="line">        MOV CX, DX</span><br><span class="line">        POP DX</span><br><span class="line">        </span><br><span class="line">        ; 交换AX的高位和低位</span><br><span class="line">        XCHG AH, AL             ; XCHG 交换指令</span><br><span class="line"></span><br><span class="line">        ; 结束程序</span><br><span class="line">        MOV AX, 4C00h</span><br><span class="line">        INT 21H</span><br><span class="line">        </span><br><span class="line">CODE ENDS</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>

<h4 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h4><p>使用DOSBox的debug指令调试：<code>debug first.exe</code></p>
<p>通过<code>t</code>指令来逐步跟进</p>
<p><img src="/2024/09/30/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C/1.1.png" alt="1.1.png"></p>
<h3 id="实验1-2-一维数值数组处理实验"><a href="#实验1-2-一维数值数组处理实验" class="headerlink" title="实验1.2 一维数值数组处理实验"></a>实验1.2 一维数值数组处理实验</h3><h4 id="实验目标-1"><a href="#实验目标-1" class="headerlink" title="实验目标"></a>实验目标</h4><p>把数据段16个字求和，然后逆序排列(无须屏幕输出)</p>
<h4 id="实验考查-1"><a href="#实验考查-1" class="headerlink" title="实验考查"></a>实验考查</h4><p>变址寻址，堆栈指令，循环指令LOOP</p>
<h4 id="实验代码-1"><a href="#实验代码-1" class="headerlink" title="实验代码"></a>实验代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODE</span><br><span class="line">CODE SEGMENT</span><br><span class="line">        DB 00H,01H,02H,03H,04H,05H,06H,07H,08H,09H,0AH,0BH,0CH,0DH,0EH,0FH     </span><br><span class="line">        SUM DB 0</span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">STACK SEGMENT</span><br><span class="line">    DW 128 DUP(0)        ; 给栈分配足够的空间</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">start:</span><br><span class="line">        ; 初始化寄存器</span><br><span class="line">        MOV AX, CODE     </span><br><span class="line">        MOV DS, AX       ; 设置数据段寄存器</span><br><span class="line">        </span><br><span class="line">        MOV AX, STACK    </span><br><span class="line">        MOV SS, AX       ; 设置栈段寄存器</span><br><span class="line">        MOV SP, 128      ; 栈指针初始化</span><br><span class="line">        </span><br><span class="line">        ; 求和并顺序入栈</span><br><span class="line">        MOV CX, 16       ; 循环次数</span><br><span class="line">        MOV SI, 0        ; 初始化CODE段指针</span><br><span class="line">        MOV AX, 0</span><br><span class="line"></span><br><span class="line">    S:  ADD AL, [SI]</span><br><span class="line">        PUSH [SI]        ; 栈顶入栈</span><br><span class="line">        INC SI</span><br><span class="line">        LOOP S</span><br><span class="line">        MOV SUM, AL      ; 将SUM的值保存到SUM中</span><br><span class="line"></span><br><span class="line">        ; 顺序出栈</span><br><span class="line">        MOV SI, 0        ; 初始化CODE段指针</span><br><span class="line">        MOV CX, 16       ; 循环次数</span><br><span class="line">        </span><br><span class="line">    D:  POP AX           ; 栈顶出栈</span><br><span class="line">        MOV [SI], AL     ; 保存到CODE段</span><br><span class="line">        INC SI</span><br><span class="line">        LOOP D</span><br><span class="line"></span><br><span class="line">        ; 结束程序</span><br><span class="line">        MOV AX, 4C00h</span><br><span class="line">        INT 21H </span><br><span class="line">CODE ENDS</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>

<h4 id="实验验证-1"><a href="#实验验证-1" class="headerlink" title="实验验证"></a>实验验证</h4><p>使用DOSBox的debug指令调试：<code>debug second.exe</code></p>
<p>通过<code>r</code>查看<code>CODE</code>段基地址为076A</p>
<p><img src="/2024/09/30/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C/1.2.1.png" alt="1.2.1.png"></p>
<p>通过<code>d</code>指令查看内存076A:0000处初始的值</p>
<p><img src="/2024/09/30/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C/1.2.2.png" alt="1.2.2.png"></p>
<p>通过<code>t</code>指令来逐步跟进，待循环结束后再次通过<code>d</code>指令查看内存076A:0000处的值</p>
<p><img src="/2024/09/30/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C/1.2.3.png" alt="1.2.3.png"></p>
<p>可见076A:0000处16个字节已经倒序排列</p>
<h3 id="实验1-3-字符串处理实验"><a href="#实验1-3-字符串处理实验" class="headerlink" title="实验1.3 字符串处理实验"></a>实验1.3 字符串处理实验</h3><h4 id="实验目标-2"><a href="#实验目标-2" class="headerlink" title="实验目标"></a>实验目标</h4><p>已知数据段有16个大小写混合的英文字母，全部改成大写。(无须屏幕输出)</p>
<h4 id="实验考查-2"><a href="#实验考查-2" class="headerlink" title="实验考查"></a>实验考查</h4><p>变址寻址，循环指令LOOP，ASCII码</p>
<h4 id="实验代码-2"><a href="#实验代码-2" class="headerlink" title="实验代码"></a>实验代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODE</span><br><span class="line">CODE SEGMENT</span><br><span class="line">        DB 41H,61H,62H,42H,43H,63H,44H,64H,45H,65H,46H,66H,67H,47H,48H,68H     </span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">start:</span><br><span class="line">        ; 初始化寄存器</span><br><span class="line">        MOV AX, CODE     </span><br><span class="line">        MOV DS, AX       ; 设置数据段寄存器 </span><br><span class="line"></span><br><span class="line">        ; 全部改成大写</span><br><span class="line">        MOV SI, 0        ; 初始化CODE段指针</span><br><span class="line">        MOV AX, 0</span><br><span class="line"></span><br><span class="line">    S:  CMP SI, 16       ; 判断是否循环结束</span><br><span class="line">        JZ FINISH</span><br><span class="line">        MOV AL, [SI]     ; 使用AX寄存器保存当前字符的ASCII码</span><br><span class="line">        CMP AL, 60H      ; 判断是否为小T写字母</span><br><span class="line">        JG D             ; 若是小写字母，则跳转到D</span><br><span class="line">        INC SI           ; 若是大写字母则指针加1</span><br><span class="line">        JMP S            ; 跳回S</span><br><span class="line"></span><br><span class="line">    D:  SUB AL, 20H      ; 大写转小写</span><br><span class="line">        MOV [SI], AL     ; 保存到CODE段</span><br><span class="line">        INC SI           ; 指针加1</span><br><span class="line">        JMP S            ; 跳回S</span><br><span class="line">        </span><br><span class="line">        ; 结束程序</span><br><span class="line">    FINISH:</span><br><span class="line">        MOV AX, 4C00h</span><br><span class="line">        INT 21H </span><br><span class="line">CODE ENDS</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>

<h4 id="实验验证-2"><a href="#实验验证-2" class="headerlink" title="实验验证"></a>实验验证</h4><p>使用DOSBox的debug指令调试：<code>debug third.exe</code></p>
<p>通过<code>g</code>执行程序，然后通过<code>d 076A:0000</code>查看此处内存中保存的数据<br><img src="/1.3.1.png" alt="1.3.1.png"></p>
<p>可以看到小写字母的ASCII码已经变成了大写字母的ASCII码</p>
<h3 id="实验1-4-二维数组处理实验"><a href="#实验1-4-二维数组处理实验" class="headerlink" title="实验1.4 二维数组处理实验"></a>实验1.4 二维数组处理实验</h3><h4 id="实验目标-3"><a href="#实验目标-3" class="headerlink" title="实验目标"></a>实验目标</h4><p>已知数据段定义有4行×8列的字数据（想象成C语言的二维数组）。求所有元素的最小值和最大值。最大值和最小值存在数组的末尾（且保证不要进入代码段）。</p>
<h4 id="实验考查-3"><a href="#实验考查-3" class="headerlink" title="实验考查"></a>实验考查</h4><p>基址+变址寻址，循环指令，变量定义和访问</p>
<h4 id="实验代码-3"><a href="#实验代码-3" class="headerlink" title="实验代码"></a>实验代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODE</span><br><span class="line">DATA SEGMENT</span><br><span class="line">        DB 8DH,7DH,2BH,27H,44H,1AH,16H,22H</span><br><span class="line">        DB 6CH,16H,10H,40H,99H,79H,99H,66H</span><br><span class="line">        DB 21H,1BH,07H,43H,51H,23H,92H,90H</span><br><span class="line">        DB 93H,01H,12H,89H,82H,47H,6BH,6CH</span><br><span class="line">        MAX DB 0</span><br><span class="line">        MIN DB 0 </span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">start:</span><br><span class="line">        ; 初始化寄存器</span><br><span class="line">        MOV AX, DATA     </span><br><span class="line">        MOV DS, AX      ; 设置数据段寄存器 </span><br><span class="line">        MOV AX, 0</span><br><span class="line">        MOV SI, 0</span><br><span class="line">        MOV BL, [SI]    ; BX寄存器用来保存临时最大值</span><br><span class="line">        MOV CL, [SI]    ; DX寄存器用来保存临时最小值</span><br><span class="line">        INC SI</span><br><span class="line"></span><br><span class="line">        ; 遍历数组并判断值大小</span><br><span class="line">    R: </span><br><span class="line">        CMP SI, 32       ; 判断数组是否遍历完</span><br><span class="line">        JZ FINISH</span><br><span class="line">        MOV AL, [SI]</span><br><span class="line">        CMP AL, BL      ; 判断下一个值是否大于当前最大值</span><br><span class="line">        JA MX           ; 若大于，则把当前最大值更新 </span><br><span class="line">        CMP AL, CL      ; 判断下一个值是否小于当前最小值</span><br><span class="line">        JB MN           ; 若小于，则把当前最小值更新</span><br><span class="line">        INC SI          ; 若该值位于最大值和最小值之间则跳转到下一个值</span><br><span class="line">        JMP R</span><br><span class="line">        </span><br><span class="line">        ; 更新最大值</span><br><span class="line">    MX:</span><br><span class="line">        MOV BL, AL</span><br><span class="line">        INC SI</span><br><span class="line">        JMP R</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        ; 更新最小值</span><br><span class="line">    MN:</span><br><span class="line">        MOV CL, AL</span><br><span class="line">        INC SI</span><br><span class="line">        JMP R</span><br><span class="line"></span><br><span class="line">    FINISH:</span><br><span class="line">        ; 保存最大和最小值</span><br><span class="line">        MOV [SI], BX</span><br><span class="line">        INC SI</span><br><span class="line">        MOV [SI], CL</span><br><span class="line">        MOV AX, 4C00h   ; 结束程序</span><br><span class="line">        INT 21H </span><br><span class="line">CODE ENDS</span><br><span class="line">END start</span><br></pre></td></tr></table></figure>

<h4 id="实验验证-3"><a href="#实验验证-3" class="headerlink" title="实验验证"></a>实验验证</h4><p>使用DOSBox的debug指令调试：<code>debug forth.exe</code></p>
<p>通过<code>g</code>执行程序，然后通过<code>d 076A:0000</code>查看此处内存中保存的数据</p>
<p><img src="/2024/09/30/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C/1.4.1.png" alt="1.4.1.png"></p>
<p>可以看到最大值为99H，最小值为01H</p>
<blockquote>
<p>注意：如果使用JG和JL去进行判断会把所有数字当成有符号的数字对比，由于8XH以上的数字最高位是1，会被看成负数去处理，此时最大值和最小值就会改变</p>
<p><img src="/2024/09/30/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C/1.4.2.png" alt="1.4.2.png"></p>
</blockquote>
]]></content>
  </entry>
</search>
